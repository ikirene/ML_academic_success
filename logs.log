2024-06-17 17:32:18,259:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2024-06-17 17:32:18,259:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2024-06-17 17:32:18,259:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2024-06-17 17:32:18,259:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2024-06-17 17:32:56,506:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,518:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,519:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,520:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,521:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,522:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,523:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,524:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,525:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,526:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,526:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,527:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,528:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,529:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,529:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,530:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,530:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,531:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,532:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,533:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,534:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,534:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,535:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,536:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,536:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,538:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,539:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,540:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,541:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,541:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,542:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,543:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,544:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,544:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,545:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,546:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,547:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,547:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,548:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,549:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,550:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,550:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,551:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,552:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,553:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,553:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,554:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,556:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,557:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,557:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,559:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,559:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,560:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,561:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,562:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,562:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,563:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,564:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,565:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,566:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,566:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,567:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,568:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,569:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,569:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,570:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,571:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,572:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,573:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,573:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,574:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,575:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,576:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,578:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,579:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,580:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,580:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,581:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,582:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,583:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,584:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,584:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,585:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,586:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,586:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,589:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,590:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,591:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,592:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,592:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,593:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,594:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,595:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,596:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,596:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,597:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,598:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,599:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,600:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,600:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,601:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,602:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,603:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,603:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,604:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,605:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,606:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,607:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,608:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,609:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,610:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,610:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,611:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,612:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,613:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,614:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,614:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,615:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,616:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,617:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,617:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,618:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,619:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,620:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,620:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,622:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,622:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,623:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,624:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,625:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,626:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,626:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,627:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,628:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,629:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,629:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,630:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,631:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,631:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,632:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,633:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,634:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,635:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,635:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,636:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,638:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,639:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,639:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,640:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,641:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,642:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,642:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,643:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,644:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,645:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,646:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,646:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,648:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,649:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,649:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,650:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,651:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,652:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,652:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,653:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,655:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,656:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,656:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,658:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,658:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,660:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,660:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,661:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,662:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,663:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,664:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,665:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,665:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,666:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,667:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,668:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,669:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,670:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,671:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,672:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,673:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,674:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,674:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,675:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,676:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,677:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,678:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,678:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,679:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,680:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,681:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,682:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,682:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,683:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,684:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,685:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,686:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,687:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,687:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,688:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,690:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,690:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,691:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,692:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,693:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,694:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,695:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,695:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,696:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,697:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,699:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,699:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,700:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,700:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,701:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,702:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,703:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,704:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,705:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,705:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,706:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,708:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,708:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,709:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,709:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,710:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,711:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,712:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,713:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,713:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,714:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,715:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,716:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,716:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,718:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,719:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,719:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,720:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,721:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,722:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,723:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,723:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,724:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,725:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,725:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,727:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,728:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,729:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,730:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,731:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,732:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,732:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,733:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,734:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,735:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,736:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,737:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,737:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,738:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,739:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,739:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,740:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,741:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,742:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,743:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,743:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,744:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,745:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,746:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,746:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,748:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,749:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,750:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,751:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,751:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,752:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,753:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,754:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,755:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,756:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,758:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,759:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,760:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,761:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,762:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,763:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,764:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,765:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,766:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,767:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,767:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,768:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,769:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,770:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,771:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,772:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,773:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,773:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,774:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,775:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,776:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,777:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,778:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,779:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,781:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,782:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,782:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,783:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,784:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,785:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,786:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,787:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,787:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,789:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,790:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,791:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,792:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,794:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,795:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,796:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,797:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,798:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,799:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,800:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,801:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,802:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,803:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,805:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,806:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,807:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,808:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,809:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,810:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,811:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,812:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,813:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,814:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,815:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,816:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,817:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,817:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,819:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,820:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,820:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,821:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,822:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,823:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,825:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,826:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,826:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,827:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,828:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,829:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,830:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,830:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,831:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,832:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,833:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,834:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,835:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,835:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,836:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,837:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,839:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,839:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,840:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,841:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,842:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,843:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,844:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,845:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,845:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,846:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,847:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,847:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,849:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,849:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,850:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,851:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,852:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,852:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,853:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,854:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,855:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,856:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,857:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,858:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,858:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,859:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,861:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,862:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,863:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,865:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,866:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,866:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,868:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:56,869:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-17 17:32:57,383:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-17 17:32:57,776:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-17 17:32:58,102:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-17 17:32:58,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,202:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,215:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,215:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,217:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,220:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,220:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,235:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,238:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,250:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,253:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,260:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,260:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,350:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,350:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,350:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,380:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,380:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:32:58,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\3515143384.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-17 17:33:05,274:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:33:08,737:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 3, 5, 6, 7, 8, 9, 10, 19, 20, 21, 24, 25] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-17 17:33:09,497:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 3, 5, 6, 7, 8, 9, 10, 19, 20, 21, 24, 25] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-17 17:33:09,736:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,738:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,739:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,740:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,742:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,743:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,744:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,746:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,748:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,750:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,751:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,753:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,755:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,756:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,758:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,760:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,762:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,763:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,765:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,767:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,769:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,771:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,772:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,774:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,774:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,775:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,778:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,779:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,780:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,781:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,782:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,784:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,785:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,787:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,789:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,790:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,792:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,793:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,795:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,795:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,796:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,797:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,799:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,800:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,800:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,802:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,804:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,806:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,808:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,809:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,810:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,812:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,814:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,816:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,816:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,818:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,819:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,820:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,822:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,823:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,824:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,825:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,827:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,828:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,829:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,830:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,832:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,834:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,835:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,836:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,838:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,840:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,841:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,842:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,843:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,845:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,846:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,846:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,848:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,849:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,850:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,851:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,853:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,854:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,856:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,858:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,859:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,860:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,861:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,863:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,865:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,866:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,868:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,869:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,871:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,872:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,873:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,875:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,876:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,878:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,880:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,881:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,882:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,884:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,886:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,886:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,889:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,891:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,892:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,893:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,894:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,896:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,897:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,898:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,898:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,899:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,899:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,900:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,900:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,901:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,903:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,904:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,906:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,909:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,909:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,910:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,912:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,914:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,915:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,916:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,919:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,921:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,922:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,922:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,924:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,926:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,927:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,929:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,931:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,933:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,934:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,936:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,939:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,940:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,943:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,945:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,947:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,948:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,950:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,951:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,953:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,954:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,956:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,959:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,959:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,960:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,961:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,962:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,964:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,966:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,966:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,968:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,970:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,970:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,970:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,972:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,973:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,975:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,976:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,979:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,982:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,984:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,985:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,988:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,989:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,991:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,993:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,994:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,996:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,997:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,997:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,998:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:09,999:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,000:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,002:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,003:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,005:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,006:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,009:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,010:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,011:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,013:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,015:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,016:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,017:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,018:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,019:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,021:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,022:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,024:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,026:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,027:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,027:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,028:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,029:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,030:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,031:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,032:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,034:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,035:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,036:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,039:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,041:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,043:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,045:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,052:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,059:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,072:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,074:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,075:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,076:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,080:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,082:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,085:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,087:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,090:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,091:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,093:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,094:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,100:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,103:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,105:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,106:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,108:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,110:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,112:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,114:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,116:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,118:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,125:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,126:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,127:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,132:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,134:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,135:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,140:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,140:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,141:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,143:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,148:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,150:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,154:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,158:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,160:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,162:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,164:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,166:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,172:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,202:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,260:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_4572\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-17 17:33:10,651:INFO:PyCaret ClassificationExperiment
2024-06-17 17:33:10,652:INFO:Logging name: clf-default-name
2024-06-17 17:33:10,652:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2024-06-17 17:33:10,652:INFO:version 3.3.2
2024-06-17 17:33:10,652:INFO:Initializing setup()
2024-06-17 17:33:10,652:INFO:self.USI: 9203
2024-06-17 17:33:10,652:INFO:self._variable_keys: {'USI', 'y_train', 'X', 'gpu_param', 'logging_param', 'fold_shuffle_param', 'y_test', '_ml_usecase', 'pipeline', 'seed', 'fold_groups_param', 'exp_name_log', '_available_plots', 'log_plots_param', 'fold_generator', 'data', 'X_test', 'exp_id', 'memory', 'target_param', 'fix_imbalance', 'idx', 'y', 'X_train', 'is_multiclass', 'n_jobs_param', 'gpu_n_jobs_param', 'html_param'}
2024-06-17 17:33:10,652:INFO:Checking environment
2024-06-17 17:33:10,652:INFO:python_version: 3.11.9
2024-06-17 17:33:10,652:INFO:python_build: ('tags/v3.11.9:de54cf5', 'Apr  2 2024 10:12:12')
2024-06-17 17:33:10,652:INFO:machine: AMD64
2024-06-17 17:33:10,652:INFO:platform: Windows-10-10.0.22631-SP0
2024-06-17 17:33:10,657:INFO:Memory: svmem(total=16804995072, available=4794634240, percent=71.5, used=12010360832, free=4794634240)
2024-06-17 17:33:10,657:INFO:Physical Core: 4
2024-06-17 17:33:10,657:INFO:Logical Core: 8
2024-06-17 17:33:10,657:INFO:Checking libraries
2024-06-17 17:33:10,657:INFO:System:
2024-06-17 17:33:10,657:INFO:    python: 3.11.9 (tags/v3.11.9:de54cf5, Apr  2 2024, 10:12:12) [MSC v.1938 64 bit (AMD64)]
2024-06-17 17:33:10,657:INFO:executable: c:\Users\irene\AppData\Local\Programs\Python\Python311\python.exe
2024-06-17 17:33:10,657:INFO:   machine: Windows-10-10.0.22631-SP0
2024-06-17 17:33:10,657:INFO:PyCaret required dependencies:
2024-06-17 17:33:10,721:INFO:                 pip: 24.0
2024-06-17 17:33:10,721:INFO:          setuptools: 65.5.0
2024-06-17 17:33:10,721:INFO:             pycaret: 3.3.2
2024-06-17 17:33:10,721:INFO:             IPython: 8.25.0
2024-06-17 17:33:10,721:INFO:          ipywidgets: 8.1.3
2024-06-17 17:33:10,721:INFO:                tqdm: 4.66.4
2024-06-17 17:33:10,721:INFO:               numpy: 1.26.4
2024-06-17 17:33:10,721:INFO:              pandas: 2.1.4
2024-06-17 17:33:10,722:INFO:              jinja2: 3.1.4
2024-06-17 17:33:10,722:INFO:               scipy: 1.11.4
2024-06-17 17:33:10,722:INFO:              joblib: 1.3.2
2024-06-17 17:33:10,722:INFO:             sklearn: 1.4.2
2024-06-17 17:33:10,722:INFO:                pyod: 2.0.0
2024-06-17 17:33:10,722:INFO:            imblearn: 0.12.3
2024-06-17 17:33:10,722:INFO:   category_encoders: 2.6.3
2024-06-17 17:33:10,722:INFO:            lightgbm: 4.4.0
2024-06-17 17:33:10,722:INFO:               numba: 0.60.0
2024-06-17 17:33:10,722:INFO:            requests: 2.32.3
2024-06-17 17:33:10,722:INFO:          matplotlib: 3.7.5
2024-06-17 17:33:10,722:INFO:          scikitplot: 0.3.7
2024-06-17 17:33:10,722:INFO:         yellowbrick: 1.5
2024-06-17 17:33:10,722:INFO:              plotly: 5.22.0
2024-06-17 17:33:10,722:INFO:    plotly-resampler: Not installed
2024-06-17 17:33:10,722:INFO:             kaleido: 0.2.1
2024-06-17 17:33:10,722:INFO:           schemdraw: 0.15
2024-06-17 17:33:10,722:INFO:         statsmodels: 0.14.2
2024-06-17 17:33:10,722:INFO:              sktime: 0.26.0
2024-06-17 17:33:10,722:INFO:               tbats: 1.1.3
2024-06-17 17:33:10,722:INFO:            pmdarima: 2.0.4
2024-06-17 17:33:10,722:INFO:              psutil: 5.9.8
2024-06-17 17:33:10,722:INFO:          markupsafe: 2.1.5
2024-06-17 17:33:10,722:INFO:             pickle5: Not installed
2024-06-17 17:33:10,722:INFO:         cloudpickle: 3.0.0
2024-06-17 17:33:10,722:INFO:         deprecation: 2.1.0
2024-06-17 17:33:10,723:INFO:              xxhash: 3.4.1
2024-06-17 17:33:10,723:INFO:           wurlitzer: Not installed
2024-06-17 17:33:10,723:INFO:PyCaret optional dependencies:
2024-06-17 17:33:10,741:INFO:                shap: Not installed
2024-06-17 17:33:10,741:INFO:           interpret: Not installed
2024-06-17 17:33:10,741:INFO:                umap: Not installed
2024-06-17 17:33:10,741:INFO:     ydata_profiling: Not installed
2024-06-17 17:33:10,741:INFO:  explainerdashboard: Not installed
2024-06-17 17:33:10,741:INFO:             autoviz: Not installed
2024-06-17 17:33:10,741:INFO:           fairlearn: Not installed
2024-06-17 17:33:10,741:INFO:          deepchecks: Not installed
2024-06-17 17:33:10,741:INFO:             xgboost: Not installed
2024-06-17 17:33:10,741:INFO:            catboost: Not installed
2024-06-17 17:33:10,741:INFO:              kmodes: Not installed
2024-06-17 17:33:10,742:INFO:             mlxtend: Not installed
2024-06-17 17:33:10,742:INFO:       statsforecast: Not installed
2024-06-17 17:33:10,742:INFO:        tune_sklearn: Not installed
2024-06-17 17:33:10,742:INFO:                 ray: Not installed
2024-06-17 17:33:10,742:INFO:            hyperopt: Not installed
2024-06-17 17:33:10,742:INFO:              optuna: Not installed
2024-06-17 17:33:10,742:INFO:               skopt: Not installed
2024-06-17 17:33:10,742:INFO:              mlflow: Not installed
2024-06-17 17:33:10,742:INFO:              gradio: Not installed
2024-06-17 17:33:10,742:INFO:             fastapi: Not installed
2024-06-17 17:33:10,742:INFO:             uvicorn: Not installed
2024-06-17 17:33:10,742:INFO:              m2cgen: Not installed
2024-06-17 17:33:10,742:INFO:           evidently: Not installed
2024-06-17 17:33:10,742:INFO:               fugue: Not installed
2024-06-17 17:33:10,742:INFO:           streamlit: Not installed
2024-06-17 17:33:10,742:INFO:             prophet: Not installed
2024-06-17 17:33:10,742:INFO:None
2024-06-17 17:33:10,742:INFO:Set up data.
2024-06-17 17:39:30,220:INFO:PyCaret ClassificationExperiment
2024-06-17 17:39:30,220:INFO:Logging name: clf-default-name
2024-06-17 17:39:30,220:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2024-06-17 17:39:30,221:INFO:version 3.3.2
2024-06-17 17:39:30,221:INFO:Initializing setup()
2024-06-17 17:39:30,221:INFO:self.USI: 6db0
2024-06-17 17:39:30,221:INFO:self._variable_keys: {'USI', 'y_train', 'X', 'gpu_param', 'logging_param', 'fold_shuffle_param', 'y_test', '_ml_usecase', 'pipeline', 'seed', 'fold_groups_param', 'exp_name_log', '_available_plots', 'log_plots_param', 'fold_generator', 'data', 'X_test', 'exp_id', 'memory', 'target_param', 'fix_imbalance', 'idx', 'y', 'X_train', 'is_multiclass', 'n_jobs_param', 'gpu_n_jobs_param', 'html_param'}
2024-06-17 17:39:30,221:INFO:Checking environment
2024-06-17 17:39:30,222:INFO:python_version: 3.11.9
2024-06-17 17:39:30,222:INFO:python_build: ('tags/v3.11.9:de54cf5', 'Apr  2 2024 10:12:12')
2024-06-17 17:39:30,222:INFO:machine: AMD64
2024-06-17 17:39:30,222:INFO:platform: Windows-10-10.0.22631-SP0
2024-06-17 17:39:30,225:INFO:Memory: svmem(total=16804995072, available=4512395264, percent=73.1, used=12292599808, free=4512395264)
2024-06-17 17:39:30,226:INFO:Physical Core: 4
2024-06-17 17:39:30,226:INFO:Logical Core: 8
2024-06-17 17:39:30,226:INFO:Checking libraries
2024-06-17 17:39:30,226:INFO:System:
2024-06-17 17:39:30,226:INFO:    python: 3.11.9 (tags/v3.11.9:de54cf5, Apr  2 2024, 10:12:12) [MSC v.1938 64 bit (AMD64)]
2024-06-17 17:39:30,226:INFO:executable: c:\Users\irene\AppData\Local\Programs\Python\Python311\python.exe
2024-06-17 17:39:30,226:INFO:   machine: Windows-10-10.0.22631-SP0
2024-06-17 17:39:30,226:INFO:PyCaret required dependencies:
2024-06-17 17:39:30,227:INFO:                 pip: 24.0
2024-06-17 17:39:30,227:INFO:          setuptools: 65.5.0
2024-06-17 17:39:30,227:INFO:             pycaret: 3.3.2
2024-06-17 17:39:30,227:INFO:             IPython: 8.25.0
2024-06-17 17:39:30,227:INFO:          ipywidgets: 8.1.3
2024-06-17 17:39:30,227:INFO:                tqdm: 4.66.4
2024-06-17 17:39:30,227:INFO:               numpy: 1.26.4
2024-06-17 17:39:30,227:INFO:              pandas: 2.1.4
2024-06-17 17:39:30,227:INFO:              jinja2: 3.1.4
2024-06-17 17:39:30,227:INFO:               scipy: 1.11.4
2024-06-17 17:39:30,227:INFO:              joblib: 1.3.2
2024-06-17 17:39:30,227:INFO:             sklearn: 1.4.2
2024-06-17 17:39:30,227:INFO:                pyod: 2.0.0
2024-06-17 17:39:30,227:INFO:            imblearn: 0.12.3
2024-06-17 17:39:30,227:INFO:   category_encoders: 2.6.3
2024-06-17 17:39:30,227:INFO:            lightgbm: 4.4.0
2024-06-17 17:39:30,227:INFO:               numba: 0.60.0
2024-06-17 17:39:30,227:INFO:            requests: 2.32.3
2024-06-17 17:39:30,228:INFO:          matplotlib: 3.7.5
2024-06-17 17:39:30,228:INFO:          scikitplot: 0.3.7
2024-06-17 17:39:30,228:INFO:         yellowbrick: 1.5
2024-06-17 17:39:30,228:INFO:              plotly: 5.22.0
2024-06-17 17:39:30,228:INFO:    plotly-resampler: Not installed
2024-06-17 17:39:30,228:INFO:             kaleido: 0.2.1
2024-06-17 17:39:30,228:INFO:           schemdraw: 0.15
2024-06-17 17:39:30,228:INFO:         statsmodels: 0.14.2
2024-06-17 17:39:30,228:INFO:              sktime: 0.26.0
2024-06-17 17:39:30,228:INFO:               tbats: 1.1.3
2024-06-17 17:39:30,228:INFO:            pmdarima: 2.0.4
2024-06-17 17:39:30,228:INFO:              psutil: 5.9.8
2024-06-17 17:39:30,228:INFO:          markupsafe: 2.1.5
2024-06-17 17:39:30,228:INFO:             pickle5: Not installed
2024-06-17 17:39:30,228:INFO:         cloudpickle: 3.0.0
2024-06-17 17:39:30,228:INFO:         deprecation: 2.1.0
2024-06-17 17:39:30,228:INFO:              xxhash: 3.4.1
2024-06-17 17:39:30,228:INFO:           wurlitzer: Not installed
2024-06-17 17:39:30,228:INFO:PyCaret optional dependencies:
2024-06-17 17:39:30,228:INFO:                shap: Not installed
2024-06-17 17:39:30,228:INFO:           interpret: Not installed
2024-06-17 17:39:30,228:INFO:                umap: Not installed
2024-06-17 17:39:30,228:INFO:     ydata_profiling: Not installed
2024-06-17 17:39:30,228:INFO:  explainerdashboard: Not installed
2024-06-17 17:39:30,228:INFO:             autoviz: Not installed
2024-06-17 17:39:30,228:INFO:           fairlearn: Not installed
2024-06-17 17:39:30,229:INFO:          deepchecks: Not installed
2024-06-17 17:39:30,229:INFO:             xgboost: Not installed
2024-06-17 17:39:30,229:INFO:            catboost: Not installed
2024-06-17 17:39:30,229:INFO:              kmodes: Not installed
2024-06-17 17:39:30,229:INFO:             mlxtend: Not installed
2024-06-17 17:39:30,229:INFO:       statsforecast: Not installed
2024-06-17 17:39:30,229:INFO:        tune_sklearn: Not installed
2024-06-17 17:39:30,229:INFO:                 ray: Not installed
2024-06-17 17:39:30,229:INFO:            hyperopt: Not installed
2024-06-17 17:39:30,229:INFO:              optuna: Not installed
2024-06-17 17:39:30,229:INFO:               skopt: Not installed
2024-06-17 17:39:30,229:INFO:              mlflow: Not installed
2024-06-17 17:39:30,229:INFO:              gradio: Not installed
2024-06-17 17:39:30,229:INFO:             fastapi: Not installed
2024-06-17 17:39:30,229:INFO:             uvicorn: Not installed
2024-06-17 17:39:30,229:INFO:              m2cgen: Not installed
2024-06-17 17:39:30,229:INFO:           evidently: Not installed
2024-06-17 17:39:30,229:INFO:               fugue: Not installed
2024-06-17 17:39:30,229:INFO:           streamlit: Not installed
2024-06-17 17:39:30,229:INFO:             prophet: Not installed
2024-06-17 17:39:30,229:INFO:None
2024-06-17 17:39:30,229:INFO:Set up data.
2024-06-17 17:39:30,744:INFO:Set up folding strategy.
2024-06-17 17:39:30,744:INFO:Set up train/test split.
2024-06-17 17:39:30,942:INFO:Set up index.
2024-06-17 17:39:30,943:INFO:Assigning column types.
2024-06-17 17:39:30,949:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2024-06-17 17:39:31,013:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,018:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,059:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,059:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,113:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,114:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,144:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,144:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,145:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2024-06-17 17:39:31,194:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,223:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,224:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,272:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:39:31,301:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,302:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,302:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2024-06-17 17:39:31,380:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,381:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,460:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,460:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,464:INFO:Set up column name cleaning.
2024-06-17 17:39:31,518:INFO:Finished creating preprocessing pipeline.
2024-06-17 17:39:31,520:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\irene\AppData\Local\Temp\joblib),
         steps=[('clean_column_names',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=CleanColumnNames(match='[\\]\\[\\,\\{\\}\\"\\:]+')))],
         verbose=False)
2024-06-17 17:39:31,520:INFO:Creating final display dataframe.
2024-06-17 17:39:31,912:INFO:Setup _display_container:                    Description        Value
0                   Session id         1830
1                       Target       Target
2                  Target type   Multiclass
3          Original data shape  (76518, 31)
4       Transformed data shape  (76518, 31)
5  Transformed train set shape  (61214, 31)
6   Transformed test set shape  (15304, 31)
7         Categorical features           30
2024-06-17 17:39:31,999:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:31,999:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:32,076:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:32,076:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:39:32,077:INFO:setup() successfully completed in 1.86s...............
2024-06-17 17:39:32,078:INFO:Initializing compare_models()
2024-06-17 17:39:32,078:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, include=None, exclude=None, fold=None, round=4, cross_validation=True, sort=Accuracy, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'Accuracy', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>})
2024-06-17 17:39:32,078:INFO:Checking exceptions
2024-06-17 17:39:32,086:INFO:Preparing display monitor
2024-06-17 17:39:32,107:INFO:Initializing Logistic Regression
2024-06-17 17:39:32,107:INFO:Total runtime is 0.0 minutes
2024-06-17 17:39:32,111:INFO:SubProcess create_model() called ==================================
2024-06-17 17:39:32,111:INFO:Initializing create_model()
2024-06-17 17:39:32,111:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:39:32,111:INFO:Checking exceptions
2024-06-17 17:39:32,111:INFO:Importing libraries
2024-06-17 17:39:32,111:INFO:Copying training dataset
2024-06-17 17:39:32,135:INFO:Defining folds
2024-06-17 17:39:32,136:INFO:Declaring metric variables
2024-06-17 17:39:32,139:INFO:Importing untrained model
2024-06-17 17:39:32,144:INFO:Logistic Regression Imported successfully
2024-06-17 17:39:32,152:INFO:Starting cross validation
2024-06-17 17:39:32,153:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:40:12,594:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:12,672:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:12,682:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:12,747:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:12,810:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:12,891:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:13,402:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:13,452:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:13,471:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:13,522:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:13,643:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:13,671:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:14,149:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:14,203:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:14,319:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,124:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:15,171:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,271:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,431:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:15,466:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,559:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,663:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:15,709:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:15,777:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:26,480:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:26,503:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:26,559:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:26,667:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:26,689:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:26,736:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:26,742:INFO:Calculating mean and std
2024-06-17 17:40:26,742:INFO:Creating metrics dataframe
2024-06-17 17:40:26,744:INFO:Uploading results into container
2024-06-17 17:40:26,745:INFO:Uploading model into container now
2024-06-17 17:40:26,745:INFO:_master_model_container: 1
2024-06-17 17:40:26,745:INFO:_display_container: 2
2024-06-17 17:40:26,745:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=1830, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2024-06-17 17:40:26,745:INFO:create_model() successfully completed......................................
2024-06-17 17:40:26,839:WARNING:create_model() for LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=1830, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False) raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:40:26,841:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

2024-06-17 17:40:26,841:INFO:Initializing create_model()
2024-06-17 17:40:26,842:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:40:26,842:INFO:Checking exceptions
2024-06-17 17:40:26,842:INFO:Importing libraries
2024-06-17 17:40:26,842:INFO:Copying training dataset
2024-06-17 17:40:26,859:INFO:Defining folds
2024-06-17 17:40:26,859:INFO:Declaring metric variables
2024-06-17 17:40:26,862:INFO:Importing untrained model
2024-06-17 17:40:26,866:INFO:Logistic Regression Imported successfully
2024-06-17 17:40:26,872:INFO:Starting cross validation
2024-06-17 17:40:26,873:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:40:58,403:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:58,467:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:58,604:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:58,804:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:58,862:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,004:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,055:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:59,137:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,268:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,818:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:59,873:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:40:59,882:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,928:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:40:59,987:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:41:00,045:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,051:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,062:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,173:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,221:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:41:00,269:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,387:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,710:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:41:00,751:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:00,829:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:14,003:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:41:14,034:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:14,085:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:14,321:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:41:14,344:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:14,395:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:41:14,399:INFO:Calculating mean and std
2024-06-17 17:41:14,400:INFO:Creating metrics dataframe
2024-06-17 17:41:14,402:INFO:Uploading results into container
2024-06-17 17:41:14,402:INFO:Uploading model into container now
2024-06-17 17:41:14,403:INFO:_master_model_container: 2
2024-06-17 17:41:14,403:INFO:_display_container: 2
2024-06-17 17:41:14,403:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=1830, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2024-06-17 17:41:14,404:INFO:create_model() successfully completed......................................
2024-06-17 17:41:14,494:ERROR:create_model() for LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=1830, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False) raised an exception or returned all 0.0:
2024-06-17 17:41:14,495:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 818, in compare_models
    np.sum(
AssertionError

2024-06-17 17:41:14,495:INFO:Initializing K Neighbors Classifier
2024-06-17 17:41:14,495:INFO:Total runtime is 1.706463305155436 minutes
2024-06-17 17:41:14,497:INFO:SubProcess create_model() called ==================================
2024-06-17 17:41:14,499:INFO:Initializing create_model()
2024-06-17 17:41:14,499:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:14,499:INFO:Checking exceptions
2024-06-17 17:41:14,499:INFO:Importing libraries
2024-06-17 17:41:14,499:INFO:Copying training dataset
2024-06-17 17:41:14,518:INFO:Defining folds
2024-06-17 17:41:14,518:INFO:Declaring metric variables
2024-06-17 17:41:14,521:INFO:Importing untrained model
2024-06-17 17:41:14,525:INFO:K Neighbors Classifier Imported successfully
2024-06-17 17:41:14,529:INFO:Starting cross validation
2024-06-17 17:41:14,530:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:41:17,042:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,221:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,367:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,517:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:17,707:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:17,709:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,751:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:17,752:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,752:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 826, in kneighbors
    X = self._validate_data(X, accept_sparse="csr", reset=False, order="C")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 633, in _validate_data
    out = check_array(X, input_name="X", **check_params)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\validation.py", line 997, in check_array
    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_array_api.py", line 521, in _asarray_with_order
    array = numpy.asarray(array, order=order, dtype=dtype)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\generic.py", line 2083, in __array__
    values = self._values
             ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\frame.py", line 1046, in _values
    return ensure_wrapped_if_datetimelike(self.values)
                                          ^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\frame.py", line 12281, in values
    return self._mgr.as_array()
           ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\internals\managers.py", line 1656, in as_array
    arr = self._interleave(dtype=dtype, na_value=na_value)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\internals\managers.py", line 1689, in _interleave
    result = np.empty(self.shape, dtype=dtype)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.40 MiB for an array with shape (30, 6122) and data type object

  warnings.warn(

2024-06-17 17:41:17,812:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:17,821:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:17,939:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:18,092:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:18,093:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:18,227:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:18,227:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:18,228:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 826, in kneighbors
    X = self._validate_data(X, accept_sparse="csr", reset=False, order="C")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 633, in _validate_data
    out = check_array(X, input_name="X", **check_params)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\validation.py", line 997, in check_array
    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_array_api.py", line 521, in _asarray_with_order
    array = numpy.asarray(array, order=order, dtype=dtype)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\generic.py", line 2083, in __array__
    values = self._values
             ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\frame.py", line 1046, in _values
    return ensure_wrapped_if_datetimelike(self.values)
                                          ^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\frame.py", line 12281, in values
    return self._mgr.as_array()
           ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\internals\managers.py", line 1656, in as_array
    arr = self._interleave(dtype=dtype, na_value=na_value)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pandas\core\internals\managers.py", line 1689, in _interleave
    result = np.empty(self.shape, dtype=dtype)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.40 MiB for an array with shape (30, 6121) and data type object

  warnings.warn(

2024-06-17 17:41:18,259:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:19,397:WARNING:create_model() for knn raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:41:19,401:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\externals\loky\process_executor.py", line 426, in _process_worker
    call_item = call_queue.get(block=True, timeout=timeout)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\queues.py", line 117, in get
    res = self._recv_bytes()
          ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 216, in recv_bytes
    buf = self._recv_bytes(maxlength)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 334, in _recv_bytes
    return self._get_more_data(ov, maxsize)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 360, in _get_more_data
    f.write(ov.getbuffer())
MemoryError
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 430, in cross_validate
    results = parallel(
              ^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
joblib.externals.loky.process_executor.BrokenProcessPool: A task has failed to un-serialize. Please ensure that the arguments of the function are all picklable.

2024-06-17 17:41:19,402:INFO:Initializing create_model()
2024-06-17 17:41:19,402:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:19,402:INFO:Checking exceptions
2024-06-17 17:41:19,402:INFO:Importing libraries
2024-06-17 17:41:19,402:INFO:Copying training dataset
2024-06-17 17:41:19,440:INFO:Defining folds
2024-06-17 17:41:19,441:INFO:Declaring metric variables
2024-06-17 17:41:19,447:INFO:Importing untrained model
2024-06-17 17:41:19,453:INFO:K Neighbors Classifier Imported successfully
2024-06-17 17:41:19,463:INFO:Starting cross validation
2024-06-17 17:41:19,464:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:41:28,141:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:28,257:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:28,373:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:28,439:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:28,463:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:28,708:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:28,708:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:28,904:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:29,105:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:29,105:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:29,292:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:29,293:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:29,331:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:29,332:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55092) and data type float64

  warnings.warn(

2024-06-17 17:41:29,396:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:29,506:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:29,830:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:29,830:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:29,853:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:29,853:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:29,938:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:30,317:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:30,379:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 338, in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 366, in predict_proba
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:30,555:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:31,327:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:31,327:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:31,327:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:31,361:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6886) and data type float64

  warnings.warn(

2024-06-17 17:41:31,362:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1875, in _parallel_pairwise
    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order="F")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 1.00 GiB for an array with shape (2436, 55093) and data type float64

  warnings.warn(

2024-06-17 17:41:31,362:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\_parallel_backends.py", line 273, in _wrap_func_call
    return func()
           ^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in __call__
    return [func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 589, in <listcomp>
    return [func(*args, **kwargs)
            ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 129, in __call__
    return self.function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1859, in _dist_wrapper
    dist_matrix[:, slice_] = dist_func(*args, **kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 186, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 347, in euclidean_distances
    return _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 382, in _euclidean_distances
    distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_classification.py", line 271, in predict
    neigh_ind = self.kneighbors(X, return_distance=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\neighbors\_base.py", line 887, in kneighbors
    chunked_results = list(
                      ^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2144, in pairwise_distances_chunked
    D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 2331, in pairwise_distances
    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\pairwise.py", line 1876, in _parallel_pairwise
    Parallel(backend="threading", n_jobs=n_jobs)(
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (2436, 6887) and data type float64

  warnings.warn(

2024-06-17 17:41:31,370:INFO:Calculating mean and std
2024-06-17 17:41:31,371:INFO:Creating metrics dataframe
2024-06-17 17:41:31,377:INFO:Uploading results into container
2024-06-17 17:41:31,379:INFO:Uploading model into container now
2024-06-17 17:41:31,380:INFO:_master_model_container: 3
2024-06-17 17:41:31,380:INFO:_display_container: 2
2024-06-17 17:41:31,381:INFO:KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform')
2024-06-17 17:41:31,381:INFO:create_model() successfully completed......................................
2024-06-17 17:41:31,545:ERROR:create_model() for KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform') raised an exception or returned all 0.0:
2024-06-17 17:41:31,550:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\externals\loky\process_executor.py", line 426, in _process_worker
    call_item = call_queue.get(block=True, timeout=timeout)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\queues.py", line 117, in get
    res = self._recv_bytes()
          ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 216, in recv_bytes
    buf = self._recv_bytes(maxlength)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 334, in _recv_bytes
    return self._get_more_data(ov, maxsize)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\multiprocessing\connection.py", line 360, in _get_more_data
    f.write(ov.getbuffer())
MemoryError
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 430, in cross_validate
    results = parallel(
              ^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\parallel.py", line 67, in __call__
    return super().__call__(iterable_with_config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1952, in __call__
    return output if self.return_generator else list(output)
                                                ^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1595, in _get_outputs
    yield from self._retrieve()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1699, in _retrieve
    self._raise_error_fast()
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 1734, in _raise_error_fast
    error_job.get_result(self.timeout)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 736, in get_result
    return self._return_or_raise()
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\parallel.py", line 754, in _return_or_raise
    raise self._result
joblib.externals.loky.process_executor.BrokenProcessPool: A task has failed to un-serialize. Please ensure that the arguments of the function are all picklable.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 818, in compare_models
    np.sum(
AssertionError

2024-06-17 17:41:31,551:INFO:Initializing Naive Bayes
2024-06-17 17:41:31,551:INFO:Total runtime is 1.9907393852869668 minutes
2024-06-17 17:41:31,558:INFO:SubProcess create_model() called ==================================
2024-06-17 17:41:31,559:INFO:Initializing create_model()
2024-06-17 17:41:31,559:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:31,559:INFO:Checking exceptions
2024-06-17 17:41:31,560:INFO:Importing libraries
2024-06-17 17:41:31,560:INFO:Copying training dataset
2024-06-17 17:41:31,619:INFO:Defining folds
2024-06-17 17:41:31,620:INFO:Declaring metric variables
2024-06-17 17:41:31,628:INFO:Importing untrained model
2024-06-17 17:41:31,636:INFO:Naive Bayes Imported successfully
2024-06-17 17:41:31,650:INFO:Starting cross validation
2024-06-17 17:41:31,652:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:41:42,236:WARNING:create_model() for nb raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:41:42,237:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 263, in fit
    return self._partial_fit(
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 431, in _partial_fit
    self.epsilon_ = self.var_smoothing * np.var(X, axis=0).max()
                                         ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\fromnumeric.py", line 3787, in var
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 163, in _var
    arrmean = um.true_divide(arrmean, div, out=arrmean,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


2024-06-17 17:41:42,238:INFO:Initializing create_model()
2024-06-17 17:41:42,238:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:42,238:INFO:Checking exceptions
2024-06-17 17:41:42,238:INFO:Importing libraries
2024-06-17 17:41:42,238:INFO:Copying training dataset
2024-06-17 17:41:42,272:INFO:Defining folds
2024-06-17 17:41:42,272:INFO:Declaring metric variables
2024-06-17 17:41:42,275:INFO:Importing untrained model
2024-06-17 17:41:42,278:INFO:Naive Bayes Imported successfully
2024-06-17 17:41:42,286:INFO:Starting cross validation
2024-06-17 17:41:42,287:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:41:52,028:ERROR:create_model() for nb raised an exception or returned all 0.0:
2024-06-17 17:41:52,029:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 263, in fit
    return self._partial_fit(
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 431, in _partial_fit
    self.epsilon_ = self.var_smoothing * np.var(X, axis=0).max()
                                         ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\fromnumeric.py", line 3787, in var
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 163, in _var
    arrmean = um.true_divide(arrmean, div, out=arrmean,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 815, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 263, in fit
    return self._partial_fit(
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\naive_bayes.py", line 431, in _partial_fit
    self.epsilon_ = self.var_smoothing * np.var(X, axis=0).max()
                                         ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\fromnumeric.py", line 3787, in var
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 163, in _var
    arrmean = um.true_divide(arrmean, div, out=arrmean,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


2024-06-17 17:41:52,030:INFO:Initializing Decision Tree Classifier
2024-06-17 17:41:52,030:INFO:Total runtime is 2.33206037680308 minutes
2024-06-17 17:41:52,033:INFO:SubProcess create_model() called ==================================
2024-06-17 17:41:52,033:INFO:Initializing create_model()
2024-06-17 17:41:52,033:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:52,033:INFO:Checking exceptions
2024-06-17 17:41:52,033:INFO:Importing libraries
2024-06-17 17:41:52,033:INFO:Copying training dataset
2024-06-17 17:41:52,053:INFO:Defining folds
2024-06-17 17:41:52,053:INFO:Declaring metric variables
2024-06-17 17:41:52,056:INFO:Importing untrained model
2024-06-17 17:41:52,059:INFO:Decision Tree Classifier Imported successfully
2024-06-17 17:41:52,065:INFO:Starting cross validation
2024-06-17 17:41:52,065:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:41:57,229:INFO:Calculating mean and std
2024-06-17 17:41:57,230:INFO:Creating metrics dataframe
2024-06-17 17:41:57,231:INFO:Uploading results into container
2024-06-17 17:41:57,232:INFO:Uploading model into container now
2024-06-17 17:41:57,232:INFO:_master_model_container: 4
2024-06-17 17:41:57,232:INFO:_display_container: 2
2024-06-17 17:41:57,233:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       monotonic_cst=None, random_state=1830, splitter='best')
2024-06-17 17:41:57,233:INFO:create_model() successfully completed......................................
2024-06-17 17:41:57,321:INFO:SubProcess create_model() end ==================================
2024-06-17 17:41:57,321:INFO:Creating metrics dataframe
2024-06-17 17:41:57,328:INFO:Initializing SVM - Linear Kernel
2024-06-17 17:41:57,328:INFO:Total runtime is 2.4203535477320353 minutes
2024-06-17 17:41:57,331:INFO:SubProcess create_model() called ==================================
2024-06-17 17:41:57,332:INFO:Initializing create_model()
2024-06-17 17:41:57,332:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:41:57,332:INFO:Checking exceptions
2024-06-17 17:41:57,332:INFO:Importing libraries
2024-06-17 17:41:57,332:INFO:Copying training dataset
2024-06-17 17:41:57,353:INFO:Defining folds
2024-06-17 17:41:57,353:INFO:Declaring metric variables
2024-06-17 17:41:57,357:INFO:Importing untrained model
2024-06-17 17:41:57,360:INFO:SVM - Linear Kernel Imported successfully
2024-06-17 17:41:57,367:INFO:Starting cross validation
2024-06-17 17:41:57,367:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:42:20,950:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:20,987:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:21,139:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:21,171:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:21,801:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:21,950:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:22,232:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:22,340:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:22,797:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:22,904:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:23,040:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:23,157:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:23,398:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:23,510:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:24,008:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:24,129:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:30,275:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:30,343:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:30,449:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:30,507:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:30,517:INFO:Calculating mean and std
2024-06-17 17:42:30,518:INFO:Creating metrics dataframe
2024-06-17 17:42:30,519:INFO:Uploading results into container
2024-06-17 17:42:30,519:INFO:Uploading model into container now
2024-06-17 17:42:30,520:INFO:_master_model_container: 5
2024-06-17 17:42:30,520:INFO:_display_container: 2
2024-06-17 17:42:30,520:INFO:SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=1830, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False)
2024-06-17 17:42:30,521:INFO:create_model() successfully completed......................................
2024-06-17 17:42:30,609:WARNING:create_model() for SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=1830, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False) raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:42:30,610:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

2024-06-17 17:42:30,610:INFO:Initializing create_model()
2024-06-17 17:42:30,610:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:42:30,610:INFO:Checking exceptions
2024-06-17 17:42:30,610:INFO:Importing libraries
2024-06-17 17:42:30,610:INFO:Copying training dataset
2024-06-17 17:42:30,629:INFO:Defining folds
2024-06-17 17:42:30,629:INFO:Declaring metric variables
2024-06-17 17:42:30,632:INFO:Importing untrained model
2024-06-17 17:42:30,634:INFO:SVM - Linear Kernel Imported successfully
2024-06-17 17:42:30,638:INFO:Starting cross validation
2024-06-17 17:42:30,639:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:42:53,005:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:53,152:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:53,822:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:53,888:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:53,954:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:54,065:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:54,670:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:54,812:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:55,374:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:55,512:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:56,418:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:56,533:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:56,811:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:56,938:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:57,464:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:42:57,587:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:03,165:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:03,253:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:03,756:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:03,826:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:03,832:INFO:Calculating mean and std
2024-06-17 17:43:03,833:INFO:Creating metrics dataframe
2024-06-17 17:43:03,835:INFO:Uploading results into container
2024-06-17 17:43:03,836:INFO:Uploading model into container now
2024-06-17 17:43:03,836:INFO:_master_model_container: 6
2024-06-17 17:43:03,836:INFO:_display_container: 2
2024-06-17 17:43:03,837:INFO:SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=1830, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False)
2024-06-17 17:43:03,837:INFO:create_model() successfully completed......................................
2024-06-17 17:43:03,946:ERROR:create_model() for SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=1830, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False) raised an exception or returned all 0.0:
2024-06-17 17:43:03,947:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 818, in compare_models
    np.sum(
AssertionError

2024-06-17 17:43:03,947:INFO:Initializing Ridge Classifier
2024-06-17 17:43:03,948:INFO:Total runtime is 3.530693221092224 minutes
2024-06-17 17:43:03,954:INFO:SubProcess create_model() called ==================================
2024-06-17 17:43:03,954:INFO:Initializing create_model()
2024-06-17 17:43:03,954:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:03,955:INFO:Checking exceptions
2024-06-17 17:43:03,955:INFO:Importing libraries
2024-06-17 17:43:03,955:INFO:Copying training dataset
2024-06-17 17:43:03,979:INFO:Defining folds
2024-06-17 17:43:03,980:INFO:Declaring metric variables
2024-06-17 17:43:03,983:INFO:Importing untrained model
2024-06-17 17:43:03,989:INFO:Ridge Classifier Imported successfully
2024-06-17 17:43:03,996:INFO:Starting cross validation
2024-06-17 17:43:03,997:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:05,432:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,437:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,558:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,579:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,618:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,729:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,907:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:05,934:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,031:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,039:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,046:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,048:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,126:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,148:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,155:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,226:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,678:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,693:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,742:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,768:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:06,778:INFO:Calculating mean and std
2024-06-17 17:43:06,779:INFO:Creating metrics dataframe
2024-06-17 17:43:06,783:INFO:Uploading results into container
2024-06-17 17:43:06,784:INFO:Uploading model into container now
2024-06-17 17:43:06,785:INFO:_master_model_container: 7
2024-06-17 17:43:06,785:INFO:_display_container: 2
2024-06-17 17:43:06,786:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=1830, solver='auto',
                tol=0.0001)
2024-06-17 17:43:06,786:INFO:create_model() successfully completed......................................
2024-06-17 17:43:06,896:WARNING:create_model() for RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=1830, solver='auto',
                tol=0.0001) raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:43:06,897:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

2024-06-17 17:43:06,897:INFO:Initializing create_model()
2024-06-17 17:43:06,897:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:06,897:INFO:Checking exceptions
2024-06-17 17:43:06,897:INFO:Importing libraries
2024-06-17 17:43:06,897:INFO:Copying training dataset
2024-06-17 17:43:06,924:INFO:Defining folds
2024-06-17 17:43:06,924:INFO:Declaring metric variables
2024-06-17 17:43:06,928:INFO:Importing untrained model
2024-06-17 17:43:06,933:INFO:Ridge Classifier Imported successfully
2024-06-17 17:43:06,943:INFO:Starting cross validation
2024-06-17 17:43:06,944:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:08,382:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,485:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,498:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,505:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,571:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,614:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,624:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,656:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,700:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,724:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,741:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,777:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,784:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,841:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,862:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:08,894:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:09,553:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:09,626:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:09,672:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:09,746:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_ridge.py", line 1253, in predict
    return super().predict(X)
           ^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:43:09,751:INFO:Calculating mean and std
2024-06-17 17:43:09,754:INFO:Creating metrics dataframe
2024-06-17 17:43:09,757:INFO:Uploading results into container
2024-06-17 17:43:09,758:INFO:Uploading model into container now
2024-06-17 17:43:09,758:INFO:_master_model_container: 8
2024-06-17 17:43:09,759:INFO:_display_container: 2
2024-06-17 17:43:09,759:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=1830, solver='auto',
                tol=0.0001)
2024-06-17 17:43:09,759:INFO:create_model() successfully completed......................................
2024-06-17 17:43:09,864:ERROR:create_model() for RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=1830, solver='auto',
                tol=0.0001) raised an exception or returned all 0.0:
2024-06-17 17:43:09,866:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 818, in compare_models
    np.sum(
AssertionError

2024-06-17 17:43:09,866:INFO:Initializing Random Forest Classifier
2024-06-17 17:43:09,866:INFO:Total runtime is 3.6293219327926636 minutes
2024-06-17 17:43:09,869:INFO:SubProcess create_model() called ==================================
2024-06-17 17:43:09,869:INFO:Initializing create_model()
2024-06-17 17:43:09,869:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=rf, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:09,869:INFO:Checking exceptions
2024-06-17 17:43:09,869:INFO:Importing libraries
2024-06-17 17:43:09,869:INFO:Copying training dataset
2024-06-17 17:43:09,901:INFO:Defining folds
2024-06-17 17:43:09,902:INFO:Declaring metric variables
2024-06-17 17:43:09,906:INFO:Importing untrained model
2024-06-17 17:43:09,909:INFO:Random Forest Classifier Imported successfully
2024-06-17 17:43:09,916:INFO:Starting cross validation
2024-06-17 17:43:09,917:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:40,010:INFO:Calculating mean and std
2024-06-17 17:43:40,012:INFO:Creating metrics dataframe
2024-06-17 17:43:40,014:INFO:Uploading results into container
2024-06-17 17:43:40,015:INFO:Uploading model into container now
2024-06-17 17:43:40,015:INFO:_master_model_container: 9
2024-06-17 17:43:40,016:INFO:_display_container: 2
2024-06-17 17:43:40,016:INFO:RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       monotonic_cst=None, n_estimators=100, n_jobs=-1,
                       oob_score=False, random_state=1830, verbose=0,
                       warm_start=False)
2024-06-17 17:43:40,016:INFO:create_model() successfully completed......................................
2024-06-17 17:43:40,131:INFO:SubProcess create_model() end ==================================
2024-06-17 17:43:40,131:INFO:Creating metrics dataframe
2024-06-17 17:43:40,140:INFO:Initializing Quadratic Discriminant Analysis
2024-06-17 17:43:40,141:INFO:Total runtime is 4.133890517552693 minutes
2024-06-17 17:43:40,144:INFO:SubProcess create_model() called ==================================
2024-06-17 17:43:40,144:INFO:Initializing create_model()
2024-06-17 17:43:40,144:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:40,144:INFO:Checking exceptions
2024-06-17 17:43:40,144:INFO:Importing libraries
2024-06-17 17:43:40,144:INFO:Copying training dataset
2024-06-17 17:43:40,176:INFO:Defining folds
2024-06-17 17:43:40,178:INFO:Declaring metric variables
2024-06-17 17:43:40,183:INFO:Importing untrained model
2024-06-17 17:43:40,186:INFO:Quadratic Discriminant Analysis Imported successfully
2024-06-17 17:43:40,193:INFO:Starting cross validation
2024-06-17 17:43:40,195:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:42,839:WARNING:create_model() for qda raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:43:42,840:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 923, in fit
    meang = Xg.mean(0)
            ^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 121, in _mean
    ret = um.true_divide(
          ^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


2024-06-17 17:43:42,840:INFO:Initializing create_model()
2024-06-17 17:43:42,840:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:42,840:INFO:Checking exceptions
2024-06-17 17:43:42,840:INFO:Importing libraries
2024-06-17 17:43:42,840:INFO:Copying training dataset
2024-06-17 17:43:42,868:INFO:Defining folds
2024-06-17 17:43:42,868:INFO:Declaring metric variables
2024-06-17 17:43:42,872:INFO:Importing untrained model
2024-06-17 17:43:42,877:INFO:Quadratic Discriminant Analysis Imported successfully
2024-06-17 17:43:42,885:INFO:Starting cross validation
2024-06-17 17:43:42,886:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:45,564:ERROR:create_model() for qda raised an exception or returned all 0.0:
2024-06-17 17:43:45,566:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 794, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 923, in fit
    meang = Xg.mean(0)
            ^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 121, in _mean
    ret = um.true_divide(
          ^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 815, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1533, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1126, in _create_model_with_cv
    scores = cross_validate(
             ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 450, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 536, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
10 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py", line 895, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 278, in fit
    fitted_estimator = self._memory_fit(
                       ^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\joblib\memory.py", line 353, in __call__
    return self.func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 69, in _fit_one
    transformer.fit(*args)
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\base.py", line 1474, in wrapper
    return fit_method(estimator, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 923, in fit
    meang = Xg.mean(0)
            ^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\numpy\core\_methods.py", line 121, in _mean
    ret = um.true_divide(
          ^^^^^^^^^^^^^^^
TypeError: unsupported operand type(s) for /: 'str' and 'int'


2024-06-17 17:43:45,568:INFO:Initializing Ada Boost Classifier
2024-06-17 17:43:45,568:INFO:Total runtime is 4.22435268163681 minutes
2024-06-17 17:43:45,570:INFO:SubProcess create_model() called ==================================
2024-06-17 17:43:45,571:INFO:Initializing create_model()
2024-06-17 17:43:45,571:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=ada, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:43:45,571:INFO:Checking exceptions
2024-06-17 17:43:45,571:INFO:Importing libraries
2024-06-17 17:43:45,571:INFO:Copying training dataset
2024-06-17 17:43:45,600:INFO:Defining folds
2024-06-17 17:43:45,601:INFO:Declaring metric variables
2024-06-17 17:43:45,605:INFO:Importing untrained model
2024-06-17 17:43:45,611:INFO:Ada Boost Classifier Imported successfully
2024-06-17 17:43:45,621:INFO:Starting cross validation
2024-06-17 17:43:45,622:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:43:45,937:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:45,994:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,031:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,071:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,105:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,143:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,183:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:43:46,213:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:45:34,386:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:34,495:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:34,756:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:35,058:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:45:35,152:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2024-06-17 17:45:35,999:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:36,273:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:36,360:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:36,499:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:45:37,073:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:46:21,942:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:46:22,071:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:46:22,232:INFO:Calculating mean and std
2024-06-17 17:46:22,233:INFO:Creating metrics dataframe
2024-06-17 17:46:22,235:INFO:Uploading results into container
2024-06-17 17:46:22,235:INFO:Uploading model into container now
2024-06-17 17:46:22,237:INFO:_master_model_container: 10
2024-06-17 17:46:22,237:INFO:_display_container: 2
2024-06-17 17:46:22,237:INFO:AdaBoostClassifier(algorithm='SAMME.R', estimator=None, learning_rate=1.0,
                   n_estimators=50, random_state=1830)
2024-06-17 17:46:22,237:INFO:create_model() successfully completed......................................
2024-06-17 17:46:22,333:INFO:SubProcess create_model() end ==================================
2024-06-17 17:46:22,334:INFO:Creating metrics dataframe
2024-06-17 17:46:22,342:INFO:Initializing Gradient Boosting Classifier
2024-06-17 17:46:22,342:INFO:Total runtime is 6.8372544487317395 minutes
2024-06-17 17:46:22,344:INFO:SubProcess create_model() called ==================================
2024-06-17 17:46:22,345:INFO:Initializing create_model()
2024-06-17 17:46:22,345:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=gbc, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:46:22,345:INFO:Checking exceptions
2024-06-17 17:46:22,345:INFO:Importing libraries
2024-06-17 17:46:22,345:INFO:Copying training dataset
2024-06-17 17:46:22,369:INFO:Defining folds
2024-06-17 17:46:22,370:INFO:Declaring metric variables
2024-06-17 17:46:22,373:INFO:Importing untrained model
2024-06-17 17:46:22,376:INFO:Gradient Boosting Classifier Imported successfully
2024-06-17 17:46:22,382:INFO:Starting cross validation
2024-06-17 17:46:22,383:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:47:38,154:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:38,945:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:38,996:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:39,446:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:39,976:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:40,014:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:40,314:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:47:40,779:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:48:22,709:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:48:23,267:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2024-06-17 17:48:23,429:INFO:Calculating mean and std
2024-06-17 17:48:23,430:INFO:Creating metrics dataframe
2024-06-17 17:48:23,432:INFO:Uploading results into container
2024-06-17 17:48:23,433:INFO:Uploading model into container now
2024-06-17 17:48:23,434:INFO:_master_model_container: 11
2024-06-17 17:48:23,434:INFO:_display_container: 2
2024-06-17 17:48:23,435:INFO:GradientBoostingClassifier(ccp_alpha=0.0, criterion='friedman_mse', init=None,
                           learning_rate=0.1, loss='log_loss', max_depth=3,
                           max_features=None, max_leaf_nodes=None,
                           min_impurity_decrease=0.0, min_samples_leaf=1,
                           min_samples_split=2, min_weight_fraction_leaf=0.0,
                           n_estimators=100, n_iter_no_change=None,
                           random_state=1830, subsample=1.0, tol=0.0001,
                           validation_fraction=0.1, verbose=0,
                           warm_start=False)
2024-06-17 17:48:23,435:INFO:create_model() successfully completed......................................
2024-06-17 17:48:23,537:INFO:SubProcess create_model() end ==================================
2024-06-17 17:48:23,537:INFO:Creating metrics dataframe
2024-06-17 17:48:23,544:INFO:Initializing Linear Discriminant Analysis
2024-06-17 17:48:23,544:INFO:Total runtime is 8.857286032040914 minutes
2024-06-17 17:48:23,547:INFO:SubProcess create_model() called ==================================
2024-06-17 17:48:23,547:INFO:Initializing create_model()
2024-06-17 17:48:23,547:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=lda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:48:23,547:INFO:Checking exceptions
2024-06-17 17:48:23,547:INFO:Importing libraries
2024-06-17 17:48:23,547:INFO:Copying training dataset
2024-06-17 17:48:23,563:INFO:Defining folds
2024-06-17 17:48:23,563:INFO:Declaring metric variables
2024-06-17 17:48:23,566:INFO:Importing untrained model
2024-06-17 17:48:23,568:INFO:Linear Discriminant Analysis Imported successfully
2024-06-17 17:48:23,572:INFO:Starting cross validation
2024-06-17 17:48:23,572:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:48:24,732:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,735:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,823:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,829:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,853:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,856:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,955:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,980:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:24,991:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,010:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,042:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,078:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,096:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,137:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,172:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:25,196:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:26,175:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:26,254:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:26,269:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:26,344:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:26,353:INFO:Calculating mean and std
2024-06-17 17:48:26,354:INFO:Creating metrics dataframe
2024-06-17 17:48:26,357:INFO:Uploading results into container
2024-06-17 17:48:26,358:INFO:Uploading model into container now
2024-06-17 17:48:26,358:INFO:_master_model_container: 12
2024-06-17 17:48:26,359:INFO:_display_container: 2
2024-06-17 17:48:26,359:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2024-06-17 17:48:26,359:INFO:create_model() successfully completed......................................
2024-06-17 17:48:26,475:WARNING:create_model() for LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001) raised an exception or returned all 0.0, trying without fit_kwargs:
2024-06-17 17:48:26,476:WARNING:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

2024-06-17 17:48:26,476:INFO:Initializing create_model()
2024-06-17 17:48:26,476:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=lda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:48:26,476:INFO:Checking exceptions
2024-06-17 17:48:26,476:INFO:Importing libraries
2024-06-17 17:48:26,476:INFO:Copying training dataset
2024-06-17 17:48:26,510:INFO:Defining folds
2024-06-17 17:48:26,510:INFO:Declaring metric variables
2024-06-17 17:48:26,514:INFO:Importing untrained model
2024-06-17 17:48:26,517:INFO:Linear Discriminant Analysis Imported successfully
2024-06-17 17:48:26,524:INFO:Starting cross validation
2024-06-17 17:48:26,525:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:48:28,244:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,319:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,402:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,420:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,471:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,479:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,513:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,550:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,574:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,614:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,642:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,676:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,703:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,733:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,738:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:28,871:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:29,945:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:29,994:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:30,048:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:30,085:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\discriminant_analysis.py", line 752, in decision_function
    return super().decision_function(X)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:48:30,087:INFO:Calculating mean and std
2024-06-17 17:48:30,087:INFO:Creating metrics dataframe
2024-06-17 17:48:30,089:INFO:Uploading results into container
2024-06-17 17:48:30,089:INFO:Uploading model into container now
2024-06-17 17:48:30,089:INFO:_master_model_container: 13
2024-06-17 17:48:30,090:INFO:_display_container: 2
2024-06-17 17:48:30,090:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2024-06-17 17:48:30,090:INFO:create_model() successfully completed......................................
2024-06-17 17:48:30,188:ERROR:create_model() for LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001) raised an exception or returned all 0.0:
2024-06-17 17:48:30,189:ERROR:Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 797, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 818, in compare_models
    np.sum(
AssertionError

2024-06-17 17:48:30,189:INFO:Initializing Extra Trees Classifier
2024-06-17 17:48:30,189:INFO:Total runtime is 8.968036274115244 minutes
2024-06-17 17:48:30,194:INFO:SubProcess create_model() called ==================================
2024-06-17 17:48:30,194:INFO:Initializing create_model()
2024-06-17 17:48:30,194:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=et, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:48:30,194:INFO:Checking exceptions
2024-06-17 17:48:30,195:INFO:Importing libraries
2024-06-17 17:48:30,195:INFO:Copying training dataset
2024-06-17 17:48:30,220:INFO:Defining folds
2024-06-17 17:48:30,221:INFO:Declaring metric variables
2024-06-17 17:48:30,224:INFO:Importing untrained model
2024-06-17 17:48:30,228:INFO:Extra Trees Classifier Imported successfully
2024-06-17 17:48:30,234:INFO:Starting cross validation
2024-06-17 17:48:30,234:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:49:01,053:INFO:Calculating mean and std
2024-06-17 17:49:01,053:INFO:Creating metrics dataframe
2024-06-17 17:49:01,056:INFO:Uploading results into container
2024-06-17 17:49:01,057:INFO:Uploading model into container now
2024-06-17 17:49:01,058:INFO:_master_model_container: 14
2024-06-17 17:49:01,058:INFO:_display_container: 2
2024-06-17 17:49:01,059:INFO:ExtraTreesClassifier(bootstrap=False, ccp_alpha=0.0, class_weight=None,
                     criterion='gini', max_depth=None, max_features='sqrt',
                     max_leaf_nodes=None, max_samples=None,
                     min_impurity_decrease=0.0, min_samples_leaf=1,
                     min_samples_split=2, min_weight_fraction_leaf=0.0,
                     monotonic_cst=None, n_estimators=100, n_jobs=-1,
                     oob_score=False, random_state=1830, verbose=0,
                     warm_start=False)
2024-06-17 17:49:01,059:INFO:create_model() successfully completed......................................
2024-06-17 17:49:01,197:INFO:SubProcess create_model() end ==================================
2024-06-17 17:49:01,198:INFO:Creating metrics dataframe
2024-06-17 17:49:01,222:INFO:Initializing Light Gradient Boosting Machine
2024-06-17 17:49:01,222:INFO:Total runtime is 9.485247687498727 minutes
2024-06-17 17:49:01,225:INFO:SubProcess create_model() called ==================================
2024-06-17 17:49:01,226:INFO:Initializing create_model()
2024-06-17 17:49:01,226:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=lightgbm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:49:01,226:INFO:Checking exceptions
2024-06-17 17:49:01,226:INFO:Importing libraries
2024-06-17 17:49:01,226:INFO:Copying training dataset
2024-06-17 17:49:01,284:INFO:Defining folds
2024-06-17 17:49:01,284:INFO:Declaring metric variables
2024-06-17 17:49:01,290:INFO:Importing untrained model
2024-06-17 17:49:01,292:INFO:Light Gradient Boosting Machine Imported successfully
2024-06-17 17:49:01,299:INFO:Starting cross validation
2024-06-17 17:49:01,300:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:49:19,100:INFO:Calculating mean and std
2024-06-17 17:49:19,101:INFO:Creating metrics dataframe
2024-06-17 17:49:19,108:INFO:Uploading results into container
2024-06-17 17:49:19,109:INFO:Uploading model into container now
2024-06-17 17:49:19,110:INFO:_master_model_container: 15
2024-06-17 17:49:19,111:INFO:_display_container: 2
2024-06-17 17:49:19,112:INFO:LGBMClassifier(boosting_type='gbdt', class_weight=None, colsample_bytree=1.0,
               importance_type='split', learning_rate=0.1, max_depth=-1,
               min_child_samples=20, min_child_weight=0.001, min_split_gain=0.0,
               n_estimators=100, n_jobs=-1, num_leaves=31, objective=None,
               random_state=1830, reg_alpha=0.0, reg_lambda=0.0, subsample=1.0,
               subsample_for_bin=200000, subsample_freq=0)
2024-06-17 17:49:19,113:INFO:create_model() successfully completed......................................
2024-06-17 17:49:19,245:INFO:SubProcess create_model() end ==================================
2024-06-17 17:49:19,245:INFO:Creating metrics dataframe
2024-06-17 17:49:19,264:INFO:Initializing Dummy Classifier
2024-06-17 17:49:19,264:INFO:Total runtime is 9.785949357350667 minutes
2024-06-17 17:49:19,269:INFO:SubProcess create_model() called ==================================
2024-06-17 17:49:19,277:INFO:Initializing create_model()
2024-06-17 17:49:19,277:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=dummy, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148846263D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:49:19,278:INFO:Checking exceptions
2024-06-17 17:49:19,278:INFO:Importing libraries
2024-06-17 17:49:19,278:INFO:Copying training dataset
2024-06-17 17:49:19,304:INFO:Defining folds
2024-06-17 17:49:19,304:INFO:Declaring metric variables
2024-06-17 17:49:19,308:INFO:Importing untrained model
2024-06-17 17:49:19,311:INFO:Dummy Classifier Imported successfully
2024-06-17 17:49:19,322:INFO:Starting cross validation
2024-06-17 17:49:19,323:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:49:19,697:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:19,764:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:19,782:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:19,866:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:19,893:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:19,935:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:20,005:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:20,048:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:20,099:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:20,145:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2024-06-17 17:49:20,259:INFO:Calculating mean and std
2024-06-17 17:49:20,259:INFO:Creating metrics dataframe
2024-06-17 17:49:20,261:INFO:Uploading results into container
2024-06-17 17:49:20,262:INFO:Uploading model into container now
2024-06-17 17:49:20,262:INFO:_master_model_container: 16
2024-06-17 17:49:20,262:INFO:_display_container: 2
2024-06-17 17:49:20,263:INFO:DummyClassifier(constant=None, random_state=1830, strategy='prior')
2024-06-17 17:49:20,263:INFO:create_model() successfully completed......................................
2024-06-17 17:49:20,376:INFO:SubProcess create_model() end ==================================
2024-06-17 17:49:20,376:INFO:Creating metrics dataframe
2024-06-17 17:49:20,406:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py:339: FutureWarning: Styler.applymap has been deprecated. Use Styler.map instead.
  .applymap(highlight_cols, subset=["TT (Sec)"])

2024-06-17 17:49:20,415:INFO:Initializing create_model()
2024-06-17 17:49:20,417:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488D799750>, estimator=LGBMClassifier(boosting_type='gbdt', class_weight=None, colsample_bytree=1.0,
               importance_type='split', learning_rate=0.1, max_depth=-1,
               min_child_samples=20, min_child_weight=0.001, min_split_gain=0.0,
               n_estimators=100, n_jobs=-1, num_leaves=31, objective=None,
               random_state=1830, reg_alpha=0.0, reg_lambda=0.0, subsample=1.0,
               subsample_for_bin=200000, subsample_freq=0), fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=False, predict=False, fit_kwargs={}, groups=None, refit=True, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=None, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:49:20,417:INFO:Checking exceptions
2024-06-17 17:49:20,421:INFO:Importing libraries
2024-06-17 17:49:20,421:INFO:Copying training dataset
2024-06-17 17:49:20,478:INFO:Defining folds
2024-06-17 17:49:20,478:INFO:Declaring metric variables
2024-06-17 17:49:20,478:INFO:Importing untrained model
2024-06-17 17:49:20,479:INFO:Declaring custom model
2024-06-17 17:49:20,481:INFO:Light Gradient Boosting Machine Imported successfully
2024-06-17 17:49:20,483:INFO:Cross validation set to False
2024-06-17 17:49:20,483:INFO:Fitting Model
2024-06-17 17:49:20,709:INFO:[LightGBM] [Warning] Found whitespace in feature_names, replace with underlines
2024-06-17 17:49:20,730:INFO:[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.007416 seconds.
2024-06-17 17:49:20,731:INFO:You can set `force_row_wise=true` to remove the overhead.
2024-06-17 17:49:20,731:INFO:And if memory is not enough, you can set `force_col_wise=true`.
2024-06-17 17:49:20,731:INFO:[LightGBM] [Info] Total Bins 488
2024-06-17 17:49:20,731:INFO:[LightGBM] [Info] Number of data points in the train set: 61214, number of used features: 30
2024-06-17 17:49:20,732:INFO:[LightGBM] [Info] Start training from score -1.106863
2024-06-17 17:49:20,732:INFO:[LightGBM] [Info] Start training from score -1.633477
2024-06-17 17:49:20,732:INFO:[LightGBM] [Info] Start training from score -0.746218
2024-06-17 17:49:22,662:INFO:LGBMClassifier(boosting_type='gbdt', class_weight=None, colsample_bytree=1.0,
               importance_type='split', learning_rate=0.1, max_depth=-1,
               min_child_samples=20, min_child_weight=0.001, min_split_gain=0.0,
               n_estimators=100, n_jobs=-1, num_leaves=31, objective=None,
               random_state=1830, reg_alpha=0.0, reg_lambda=0.0, subsample=1.0,
               subsample_for_bin=200000, subsample_freq=0)
2024-06-17 17:49:22,662:INFO:create_model() successfully completed......................................
2024-06-17 17:49:22,845:INFO:_master_model_container: 16
2024-06-17 17:49:22,845:INFO:_display_container: 2
2024-06-17 17:49:22,846:INFO:LGBMClassifier(boosting_type='gbdt', class_weight=None, colsample_bytree=1.0,
               importance_type='split', learning_rate=0.1, max_depth=-1,
               min_child_samples=20, min_child_weight=0.001, min_split_gain=0.0,
               n_estimators=100, n_jobs=-1, num_leaves=31, objective=None,
               random_state=1830, reg_alpha=0.0, reg_lambda=0.0, subsample=1.0,
               subsample_for_bin=200000, subsample_freq=0)
2024-06-17 17:49:22,846:INFO:compare_models() successfully completed......................................
2024-06-17 17:54:09,274:INFO:PyCaret ClassificationExperiment
2024-06-17 17:54:09,274:INFO:Logging name: clf-default-name
2024-06-17 17:54:09,275:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2024-06-17 17:54:09,275:INFO:version 3.3.2
2024-06-17 17:54:09,275:INFO:Initializing setup()
2024-06-17 17:54:09,275:INFO:self.USI: b1d3
2024-06-17 17:54:09,275:INFO:self._variable_keys: {'USI', 'y_train', 'X', 'gpu_param', 'logging_param', 'fold_shuffle_param', 'y_test', '_ml_usecase', 'pipeline', 'seed', 'fold_groups_param', 'exp_name_log', '_available_plots', 'log_plots_param', 'fold_generator', 'data', 'X_test', 'exp_id', 'memory', 'target_param', 'fix_imbalance', 'idx', 'y', 'X_train', 'is_multiclass', 'n_jobs_param', 'gpu_n_jobs_param', 'html_param'}
2024-06-17 17:54:09,275:INFO:Checking environment
2024-06-17 17:54:09,275:INFO:python_version: 3.11.9
2024-06-17 17:54:09,275:INFO:python_build: ('tags/v3.11.9:de54cf5', 'Apr  2 2024 10:12:12')
2024-06-17 17:54:09,275:INFO:machine: AMD64
2024-06-17 17:54:09,275:INFO:platform: Windows-10-10.0.22631-SP0
2024-06-17 17:54:09,277:INFO:Memory: svmem(total=16804995072, available=3102633984, percent=81.5, used=13702361088, free=3102633984)
2024-06-17 17:54:09,278:INFO:Physical Core: 4
2024-06-17 17:54:09,278:INFO:Logical Core: 8
2024-06-17 17:54:09,278:INFO:Checking libraries
2024-06-17 17:54:09,278:INFO:System:
2024-06-17 17:54:09,278:INFO:    python: 3.11.9 (tags/v3.11.9:de54cf5, Apr  2 2024, 10:12:12) [MSC v.1938 64 bit (AMD64)]
2024-06-17 17:54:09,278:INFO:executable: c:\Users\irene\AppData\Local\Programs\Python\Python311\python.exe
2024-06-17 17:54:09,278:INFO:   machine: Windows-10-10.0.22631-SP0
2024-06-17 17:54:09,278:INFO:PyCaret required dependencies:
2024-06-17 17:54:09,278:INFO:                 pip: 24.0
2024-06-17 17:54:09,278:INFO:          setuptools: 65.5.0
2024-06-17 17:54:09,278:INFO:             pycaret: 3.3.2
2024-06-17 17:54:09,278:INFO:             IPython: 8.25.0
2024-06-17 17:54:09,278:INFO:          ipywidgets: 8.1.3
2024-06-17 17:54:09,278:INFO:                tqdm: 4.66.4
2024-06-17 17:54:09,278:INFO:               numpy: 1.26.4
2024-06-17 17:54:09,278:INFO:              pandas: 2.1.4
2024-06-17 17:54:09,278:INFO:              jinja2: 3.1.4
2024-06-17 17:54:09,278:INFO:               scipy: 1.11.4
2024-06-17 17:54:09,278:INFO:              joblib: 1.3.2
2024-06-17 17:54:09,278:INFO:             sklearn: 1.4.2
2024-06-17 17:54:09,278:INFO:                pyod: 2.0.0
2024-06-17 17:54:09,278:INFO:            imblearn: 0.12.3
2024-06-17 17:54:09,278:INFO:   category_encoders: 2.6.3
2024-06-17 17:54:09,278:INFO:            lightgbm: 4.4.0
2024-06-17 17:54:09,278:INFO:               numba: 0.60.0
2024-06-17 17:54:09,278:INFO:            requests: 2.32.3
2024-06-17 17:54:09,278:INFO:          matplotlib: 3.7.5
2024-06-17 17:54:09,278:INFO:          scikitplot: 0.3.7
2024-06-17 17:54:09,278:INFO:         yellowbrick: 1.5
2024-06-17 17:54:09,278:INFO:              plotly: 5.22.0
2024-06-17 17:54:09,279:INFO:    plotly-resampler: Not installed
2024-06-17 17:54:09,279:INFO:             kaleido: 0.2.1
2024-06-17 17:54:09,279:INFO:           schemdraw: 0.15
2024-06-17 17:54:09,279:INFO:         statsmodels: 0.14.2
2024-06-17 17:54:09,279:INFO:              sktime: 0.26.0
2024-06-17 17:54:09,279:INFO:               tbats: 1.1.3
2024-06-17 17:54:09,279:INFO:            pmdarima: 2.0.4
2024-06-17 17:54:09,279:INFO:              psutil: 5.9.8
2024-06-17 17:54:09,279:INFO:          markupsafe: 2.1.5
2024-06-17 17:54:09,279:INFO:             pickle5: Not installed
2024-06-17 17:54:09,279:INFO:         cloudpickle: 3.0.0
2024-06-17 17:54:09,279:INFO:         deprecation: 2.1.0
2024-06-17 17:54:09,279:INFO:              xxhash: 3.4.1
2024-06-17 17:54:09,279:INFO:           wurlitzer: Not installed
2024-06-17 17:54:09,279:INFO:PyCaret optional dependencies:
2024-06-17 17:54:09,279:INFO:                shap: Not installed
2024-06-17 17:54:09,279:INFO:           interpret: Not installed
2024-06-17 17:54:09,279:INFO:                umap: Not installed
2024-06-17 17:54:09,279:INFO:     ydata_profiling: Not installed
2024-06-17 17:54:09,279:INFO:  explainerdashboard: Not installed
2024-06-17 17:54:09,279:INFO:             autoviz: Not installed
2024-06-17 17:54:09,279:INFO:           fairlearn: Not installed
2024-06-17 17:54:09,279:INFO:          deepchecks: Not installed
2024-06-17 17:54:09,279:INFO:             xgboost: Not installed
2024-06-17 17:54:09,279:INFO:            catboost: Not installed
2024-06-17 17:54:09,279:INFO:              kmodes: Not installed
2024-06-17 17:54:09,279:INFO:             mlxtend: Not installed
2024-06-17 17:54:09,279:INFO:       statsforecast: Not installed
2024-06-17 17:54:09,279:INFO:        tune_sklearn: Not installed
2024-06-17 17:54:09,279:INFO:                 ray: Not installed
2024-06-17 17:54:09,279:INFO:            hyperopt: Not installed
2024-06-17 17:54:09,279:INFO:              optuna: Not installed
2024-06-17 17:54:09,280:INFO:               skopt: Not installed
2024-06-17 17:54:09,280:INFO:              mlflow: Not installed
2024-06-17 17:54:09,280:INFO:              gradio: Not installed
2024-06-17 17:54:09,280:INFO:             fastapi: Not installed
2024-06-17 17:54:09,280:INFO:             uvicorn: Not installed
2024-06-17 17:54:09,280:INFO:              m2cgen: Not installed
2024-06-17 17:54:09,280:INFO:           evidently: Not installed
2024-06-17 17:54:09,280:INFO:               fugue: Not installed
2024-06-17 17:54:09,280:INFO:           streamlit: Not installed
2024-06-17 17:54:09,280:INFO:             prophet: Not installed
2024-06-17 17:54:09,280:INFO:None
2024-06-17 17:54:09,280:INFO:Set up data.
2024-06-17 17:54:09,554:INFO:Set up folding strategy.
2024-06-17 17:54:09,554:INFO:Set up train/test split.
2024-06-17 17:54:09,614:INFO:Set up index.
2024-06-17 17:54:09,615:INFO:Assigning column types.
2024-06-17 17:54:09,619:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2024-06-17 17:54:09,661:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,662:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,683:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,683:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,720:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,720:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,743:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,744:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,744:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2024-06-17 17:54:09,781:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,801:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,801:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,839:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2024-06-17 17:54:09,861:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,861:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,861:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2024-06-17 17:54:09,917:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,917:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,974:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,974:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:09,976:INFO:Set up column name cleaning.
2024-06-17 17:54:10,015:INFO:Finished creating preprocessing pipeline.
2024-06-17 17:54:10,016:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\irene\AppData\Local\Temp\joblib),
         steps=[('clean_column_names',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=CleanColumnNames(match='[\\]\\[\\,\\{\\}\\"\\:]+')))],
         verbose=False)
2024-06-17 17:54:10,016:INFO:Creating final display dataframe.
2024-06-17 17:54:10,340:INFO:Setup _display_container:                    Description        Value
0                   Session id         7582
1                       Target       Target
2                  Target type   Multiclass
3          Original data shape  (76518, 31)
4       Transformed data shape  (76518, 31)
5  Transformed train set shape  (61214, 31)
6   Transformed test set shape  (15304, 31)
7         Categorical features           30
2024-06-17 17:54:10,417:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:10,418:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:10,486:WARNING:
'xgboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install xgboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:10,486:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2024-06-17 17:54:10,487:INFO:setup() successfully completed in 1.21s...............
2024-06-17 17:54:10,489:INFO:Initializing compare_models()
2024-06-17 17:54:10,489:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488575F110>, include=None, exclude=None, fold=None, round=4, cross_validation=True, sort=Accuracy, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x000001488575F110>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'Accuracy', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>})
2024-06-17 17:54:10,489:INFO:Checking exceptions
2024-06-17 17:54:10,498:INFO:Preparing display monitor
2024-06-17 17:54:10,517:INFO:Initializing Logistic Regression
2024-06-17 17:54:10,517:INFO:Total runtime is 0.0 minutes
2024-06-17 17:54:10,520:INFO:SubProcess create_model() called ==================================
2024-06-17 17:54:10,521:INFO:Initializing create_model()
2024-06-17 17:54:10,521:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001488575F110>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000148850789D0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2024-06-17 17:54:10,521:INFO:Checking exceptions
2024-06-17 17:54:10,521:INFO:Importing libraries
2024-06-17 17:54:10,521:INFO:Copying training dataset
2024-06-17 17:54:10,545:INFO:Defining folds
2024-06-17 17:54:10,545:INFO:Declaring metric variables
2024-06-17 17:54:10,551:INFO:Importing untrained model
2024-06-17 17:54:10,555:INFO:Logistic Regression Imported successfully
2024-06-17 17:54:10,565:INFO:Starting cross validation
2024-06-17 17:54:10,567:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2024-06-17 17:54:43,408:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:43,491:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,497:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,576:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:43,579:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:43,627:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:43,635:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,651:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,723:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,723:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,759:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,760:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,842:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:43,851:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,867:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:43,908:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:44,034:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:44,137:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:44,157:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-17 17:54:44,200:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:44,217:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
           ^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 350, in decision_function
    return self.steps[-1][-1].decision_function(X, **params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:44,328:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-17 17:54:44,335:WARNING:c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\model_selection\_validation.py:1011: UserWarning: Scoring failed. The score on this train-test partition for these parameters will be set to 0.0. Details: 
Traceback (most recent call last):
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 137, in __call__
    score = scorer._score(
            ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 345, in _score
    y_pred = method_caller(
             ^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\metrics\_scorer.py", line 87, in _cached_call
    result, _ = _get_response_values(
                ^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\_response.py", line 210, in _get_response_values
    y_pred = prediction_method(X)
             ^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\pycaret\internal\pipeline.py", line 330, in predict
    y = self.steps[-1][-1].predict(X, **params)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 351, in predict
    scores = self.decision_function(X)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\linear_model\_base.py", line 333, in decision_function
    scores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\Users\irene\AppData\Local\Programs\Python\Python311\Lib\site-packages\sklearn\utils\extmath.py", line 208, in safe_sparse_dot
    ret = a @ b
          ~~^~~
TypeError: can't multiply sequence by non-int of type 'float'

  warnings.warn(

2024-06-22 21:03:53,994:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,995:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,996:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,996:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,997:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,998:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,998:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,999:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,999:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:53,999:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,000:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,001:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,001:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,002:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,002:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,003:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,003:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,004:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,004:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,005:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,005:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,006:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,007:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,007:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,008:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,008:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,009:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,010:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,010:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,011:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,011:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,013:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,014:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,014:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,015:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,015:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,016:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,016:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,017:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,017:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,018:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,018:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,019:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,019:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,020:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,020:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,021:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,021:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,022:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,022:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,023:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,024:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,024:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,025:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,026:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,027:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,028:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,028:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,029:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,030:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,031:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,031:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,032:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,032:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,033:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,034:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,034:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,035:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,035:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,036:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,037:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,037:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,038:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,038:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,039:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,039:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,039:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,040:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,041:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,041:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,042:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,043:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,045:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,050:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,052:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,057:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,057:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,059:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,070:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,070:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,073:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,073:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,074:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,075:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,075:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,076:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,077:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,080:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,081:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,081:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,082:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,082:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,083:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,083:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,084:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,085:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,085:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,086:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,086:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,087:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,087:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,088:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,088:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,091:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,091:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,092:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,093:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,094:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,095:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,100:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,100:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,102:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,102:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,103:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,104:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,104:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,105:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,105:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,106:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,106:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,107:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,108:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,109:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,109:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,110:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,111:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,112:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,112:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,113:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,113:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,114:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,114:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,115:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,116:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,116:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,117:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,117:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,118:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,118:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,119:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,119:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,120:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,122:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,122:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,124:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,124:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,125:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,126:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,127:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,128:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,130:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,130:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,132:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,133:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,133:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,134:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,134:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,135:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,135:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,137:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,140:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,140:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,141:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,141:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,142:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,143:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,144:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,146:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,146:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,148:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,150:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,153:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,153:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,154:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,158:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,158:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,159:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,159:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,160:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,161:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,162:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,162:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,163:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,164:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,164:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,165:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,165:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,166:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,168:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,168:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,171:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,172:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,172:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,173:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,173:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,202:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,202:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,215:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,217:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,220:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,235:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,235:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,238:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,250:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:03:54,608:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:03:54,788:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:03:54,979:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:03:55,039:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,040:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,040:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,040:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,041:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,041:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,042:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,042:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,042:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,043:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,043:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,043:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,044:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,045:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,045:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,045:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,046:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,047:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,048:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,049:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,050:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,050:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,050:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,051:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,053:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,054:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,055:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,056:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,057:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,057:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,057:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,058:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,059:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,059:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,059:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,060:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,061:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,061:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,061:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,061:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,062:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,063:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,064:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,065:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,066:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,067:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,068:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,069:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,070:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,070:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,070:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,071:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,072:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,072:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,072:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,073:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,073:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,073:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,074:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,074:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,075:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,075:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,076:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,077:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,077:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,078:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,079:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,080:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,080:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,080:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,081:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,081:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,082:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,082:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,083:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,083:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,084:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,084:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,085:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,085:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,086:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,086:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,086:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,087:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,088:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,088:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,089:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,090:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,091:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,092:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,093:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,094:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,094:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,095:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,095:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,095:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,096:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,097:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,098:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,099:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,100:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,100:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,101:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,102:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,102:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,102:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,103:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,103:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,104:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,105:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,105:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,106:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,107:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,108:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,109:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,109:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,110:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,110:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,111:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,111:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,113:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,113:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,114:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,114:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,115:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,115:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,115:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,115:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,116:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,116:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,117:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,117:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,118:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,119:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,119:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,120:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,120:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,121:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,122:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,122:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,122:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,123:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,124:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,124:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,125:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,125:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,126:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,126:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,126:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,127:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,127:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,127:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,128:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,128:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,128:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,129:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,130:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,131:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,132:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,132:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,132:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,133:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,133:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,133:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,134:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,134:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,135:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,135:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,136:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,137:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,137:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,138:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,139:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,139:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,140:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,141:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,142:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,142:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,143:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,143:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,143:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,144:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,144:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,145:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,146:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,146:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,146:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,147:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,148:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,148:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,148:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,149:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,150:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,150:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,150:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,151:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,152:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,153:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,153:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,153:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,154:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,154:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,155:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,156:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,158:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,158:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,159:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,161:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,161:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,162:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,162:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,163:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,163:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,164:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,164:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,165:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,165:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,166:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,166:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,166:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,167:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,168:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,168:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,168:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,169:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,170:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,171:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,171:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,171:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,173:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,173:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,173:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,190:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:03:55,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:00,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,235:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,238:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,238:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,253:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,260:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,350:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,350:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,380:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,391:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,391:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,392:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,392:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,393:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,393:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,394:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,395:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,395:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,396:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,396:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,397:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,398:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,398:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,399:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,400:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,401:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,402:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,403:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,403:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,404:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,405:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,405:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,406:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,406:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,407:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,408:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,408:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,409:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,409:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,409:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,410:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,411:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,411:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,413:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,413:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,414:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,415:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,415:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,416:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,416:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,416:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,418:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,418:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,419:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,419:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,420:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,421:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,421:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,422:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,423:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,423:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,424:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,424:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,425:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,425:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,426:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,426:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,427:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,428:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,428:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,429:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,429:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,430:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,431:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,431:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,432:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,432:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,433:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,433:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,434:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,434:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,435:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,436:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,437:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,437:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,438:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,438:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,439:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,439:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,439:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,441:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,442:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,442:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,443:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,443:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,444:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,445:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,445:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,446:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,446:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,447:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,448:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,448:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,449:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,449:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,449:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,450:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,450:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,451:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,453:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,453:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,454:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,455:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,455:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,456:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,456:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,457:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,458:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,458:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,461:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:07:00,786:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:07:00,996:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:07:01,200:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:07:01,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,310:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,380:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,380:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,390:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:07:01,390:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_14788\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:49,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,202:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,214:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,215:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,215:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,216:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,217:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,218:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,219:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,220:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,221:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,222:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,223:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,224:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,225:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,226:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,227:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,228:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,229:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,230:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,231:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,232:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,233:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,234:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,235:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,236:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,237:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,238:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,239:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,240:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,241:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,242:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,243:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,244:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,245:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,246:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,247:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,248:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,249:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,250:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,250:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,251:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,252:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,253:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,254:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,255:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,256:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,257:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,258:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,259:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,261:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,262:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,263:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,270:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,282:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,300:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,330:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,358:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,359:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,360:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,361:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,362:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,363:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,364:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,365:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,366:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,367:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,368:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,369:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,370:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,371:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,372:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,373:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,374:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,375:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,376:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,377:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,378:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,379:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,381:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,382:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,383:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,384:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,385:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,386:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,387:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,388:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,389:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,390:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,390:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,391:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,392:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,392:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,393:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,393:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,394:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,394:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,395:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,396:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,396:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,397:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,397:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,398:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,398:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,399:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,400:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,400:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,401:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,402:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,402:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,403:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,404:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,404:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,405:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,406:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,406:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,407:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,407:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,408:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,409:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,409:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,410:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,410:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,411:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,411:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,412:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,412:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,413:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,413:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,414:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,415:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,415:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,416:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,416:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,417:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,417:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,418:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,419:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,419:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,419:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,421:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,422:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,423:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,423:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4293143734.py:1: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_train[columnas] = hot_enc.transform(X_train)

2024-06-22 21:13:49,791:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:13:49,949:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:13:50,113:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 7, 8, 9, 10, 20, 22, 23] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:13:50,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,174:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,175:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,176:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,177:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,178:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,179:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,180:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,181:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,182:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,183:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,184:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,185:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,186:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,187:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,188:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,189:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,191:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,192:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,193:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,194:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,195:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,196:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,197:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,198:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,199:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,200:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,201:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,203:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,204:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,205:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,206:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,207:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,208:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,209:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,210:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,211:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,212:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,213:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,264:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,265:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,266:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,267:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,268:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,269:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,271:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,272:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,273:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,274:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,275:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,276:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,277:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,278:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,279:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,280:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,281:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,283:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,284:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,285:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,286:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,287:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,288:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,289:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,290:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,291:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,292:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,293:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,294:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,295:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,296:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,297:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,298:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,299:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,301:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,302:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,303:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,304:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,305:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,306:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,307:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,308:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,309:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,311:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,312:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,313:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,314:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,315:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,316:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,317:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,318:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,319:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,320:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,321:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,322:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,323:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,324:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,325:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,326:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,327:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,328:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,329:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,331:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,332:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,333:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,334:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,335:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,336:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,337:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,338:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,339:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,340:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,341:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,342:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,343:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,344:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,345:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,346:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,347:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,348:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,349:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,351:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,352:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,353:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,354:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,355:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,356:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:50,357:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\2227373046.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  X_test[columnas_test] = hot_enc.transform(X_test)

2024-06-22 21:13:55,296:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\linear_model\_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(

2024-06-22 21:13:56,937:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 3, 5, 6, 7, 8, 9, 10, 19, 20, 21, 24, 25] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:13:57,292:WARNING:C:\Users\irene\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\sklearn\preprocessing\_encoders.py:241: UserWarning: Found unknown categories in columns [1, 3, 5, 6, 7, 8, 9, 10, 19, 20, 21, 24, 25] during transform. These unknown categories will be encoded as all zeros
  warnings.warn(

2024-06-22 21:13:57,447:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,447:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,448:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,448:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,449:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,449:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,450:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,450:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,451:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,451:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,452:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,452:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,453:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,453:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,454:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,454:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,455:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,455:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,456:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,456:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,457:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,457:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,458:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,458:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,459:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,461:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,461:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,462:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,462:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,463:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,464:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,464:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,465:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,465:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,466:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,466:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,467:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,467:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,468:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,468:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,469:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,469:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,470:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,470:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,471:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,471:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,472:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,472:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,473:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,473:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,474:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,474:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,475:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,475:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,476:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,476:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,477:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,477:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,478:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,479:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,479:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,479:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,481:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,481:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,481:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,482:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,482:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,483:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,483:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,484:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,484:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,485:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,485:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,486:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,487:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,487:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,488:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,488:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,489:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,489:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,489:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,491:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,491:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,492:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,492:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,493:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,493:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,494:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,494:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,495:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,495:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,496:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,497:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,497:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,498:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,498:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,499:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,499:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,500:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,500:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,501:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,501:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,501:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,502:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,502:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,503:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,503:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,504:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,505:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,505:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,506:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,506:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,507:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,507:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,508:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,508:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,509:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,509:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,511:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,511:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,512:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,512:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,513:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,513:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,514:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,514:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,515:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,515:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,516:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,516:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,517:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,517:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,518:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,518:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,519:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,520:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,520:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,521:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,521:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,521:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,522:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,522:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,523:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,523:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,524:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,524:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,525:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,525:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,526:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,526:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,527:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,527:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,528:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,529:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,529:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,529:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,531:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,531:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,532:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,532:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,533:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,533:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,534:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,534:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,535:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,535:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,536:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,537:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,537:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,538:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,538:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,539:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,539:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,539:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,541:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,541:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,542:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,542:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,543:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,543:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,544:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,544:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,545:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,545:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,546:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,547:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,547:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,548:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,548:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,549:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,549:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,550:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,550:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,551:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,551:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,551:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,552:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,553:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,553:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,554:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,554:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,555:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,555:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,556:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,556:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,557:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,557:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,558:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,558:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,559:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,559:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,561:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,561:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,562:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,562:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,563:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,564:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,564:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,565:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,565:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,566:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,566:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,567:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,567:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,568:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,568:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,569:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,569:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,570:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,571:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,571:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,571:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,573:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,573:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,574:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,574:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,575:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,575:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,576:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,576:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,577:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,579:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,579:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,579:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,581:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,581:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,581:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,583:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,583:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,584:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,584:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,585:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,585:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,586:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,586:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,587:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,587:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,588:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,589:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,589:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,590:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,590:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,591:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,591:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,591:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,592:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,593:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,593:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,594:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,594:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,595:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,596:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,597:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,597:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,598:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,599:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,599:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,599:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,601:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,602:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,602:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,603:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,603:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,604:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,604:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,605:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,606:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,606:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,607:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,607:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,608:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,609:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,609:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,610:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,610:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,611:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,611:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,611:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,612:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,613:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,613:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,614:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,614:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,615:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,615:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,616:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,617:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,617:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,618:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,618:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,619:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,619:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,619:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,621:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,621:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,622:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,622:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,623:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,624:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,624:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,625:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,625:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,626:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,626:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,627:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,627:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,628:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,629:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,629:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,629:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,631:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,631:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,632:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,633:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,633:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,634:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,634:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,635:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,635:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,636:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,636:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,637:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,638:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,638:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,639:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,639:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,640:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,640:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,641:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,641:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,642:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,642:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,643:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,643:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,644:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,644:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,645:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,646:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,646:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,647:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,647:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,648:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,649:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,649:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,649:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,651:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,651:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,652:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,652:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,653:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,653:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,654:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,655:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,655:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,656:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,656:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,657:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,657:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,658:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,659:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,659:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,660:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,660:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,661:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,661:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,662:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,662:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,663:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,664:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,664:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,665:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,665:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,666:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,666:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,667:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,668:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,668:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,669:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

2024-06-22 21:13:57,669:WARNING:C:\Users\irene\AppData\Local\Temp\ipykernel_13756\4281795487.py:2: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test[columnas_sub] = hot_enc.transform(test)

